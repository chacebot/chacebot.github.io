<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-09-26T10:04:48-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Chace’s Tech Blog</title><entry><title type="html">Update for Future Posts</title><link href="http://localhost:4000/2020/09/26/Update.html" rel="alternate" type="text/html" title="Update for Future Posts" /><published>2020-09-26T00:00:00-04:00</published><updated>2020-09-26T00:00:00-04:00</updated><id>http://localhost:4000/2020/09/26/Update</id><content type="html" xml:base="http://localhost:4000/2020/09/26/Update.html">&lt;p&gt;Short post here because I am busy learning. Currently on a parrallel path of HTML + CSS (to make this blog easier to look at) in addition to working on a tutorial for Webots - a robotics physics engine with an integrated control code  development enviroment. My goal with Webots is to use it to learn inverse kinematics and apply that to the motion of a robotic arm assembly using the Robotics Library.&lt;/p&gt;

&lt;p&gt;Anyways, here is a short list of topics I plan on discussing in the future when I have time to write about them:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Motion Allocator on chacebot&lt;/li&gt;
  &lt;li&gt;Cpp Testing&lt;/li&gt;
  &lt;li&gt;Using vim&lt;/li&gt;
  &lt;li&gt;Using sockets to communicate between python and cpp&lt;/li&gt;
  &lt;li&gt;Launching programs on boot with raspberry pi&lt;/li&gt;
  &lt;li&gt;Shell scripts&lt;/li&gt;
  &lt;li&gt;Custom HTML + CSS&lt;/li&gt;
  &lt;li&gt;Javascript&lt;/li&gt;
  &lt;li&gt;Python backend with Apache server on google cloud&lt;/li&gt;
  &lt;li&gt;Robotics motion control with Inverse Kinematics&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Short post here because I am busy learning. Currently on a parrallel path of HTML + CSS (to make this blog easier to look at) in addition to working on a tutorial for Webots - a robotics physics engine with an integrated control code development enviroment. My goal with Webots is to use it to learn inverse kinematics and apply that to the motion of a robotic arm assembly using the Robotics Library.</summary></entry><entry><title type="html">Code Walkthrough, Modular RC Reciever Software App</title><link href="http://localhost:4000/2020/08/30/LocalController.html" rel="alternate" type="text/html" title="Code Walkthrough, Modular RC Reciever Software App" /><published>2020-08-30T00:00:00-04:00</published><updated>2020-08-30T00:00:00-04:00</updated><id>http://localhost:4000/2020/08/30/LocalController</id><content type="html" xml:base="http://localhost:4000/2020/08/30/LocalController.html">&lt;p&gt;The purpose of this post is to outline the key components of a ROS node I wrote about three months ago in order to create my over complicated RC car. But I have already used the work dedicated here to enable other technologies across my Mechanical Engineering discipline. Such as the rapid prototyping of a mechanism that allows a 150 lb sidewalk delivery robot to climb curbs:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blog/august2020/differential_oscillation.gif&quot; alt=&quot;differential&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The source code mentioned in this post can be found here: &lt;a href=&quot;https://github.com/chacebot/chacebot_ws/tree/master/src/local_controller&quot;&gt;Local Controller Node&lt;/a&gt;. Let’s get started.&lt;/p&gt;

&lt;p&gt;As you may have read in my June post, Chacebot has a STM32 - Cortex M4 based microcontroller that rapidly publishes three axis potentiometer signals from the RC reciever. This is done in the format of; steering, drive, enable_status.&lt;/p&gt;

&lt;p&gt;The C++ local controller node’s main function holds a default file read location which is the absolute file location of the USB device sending the serial data (the STM32). This path is passed to the constructor of the Local Controller class as an initializer argument along with the ROS node handle and the defined loop rate of the node. Currently this loop rate is defined as 50hz.&lt;/p&gt;

&lt;p&gt;The Local Controller constructor utilizes the Boost ASIO (Asnychronous Input Output) library in order to connect the app with the streaming data. In order to create the serial stream, the constructor passes the serial device path to the boost serial handle via uniform initialization as shown below:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;LocalController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LocalController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ros&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NodeHandle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                 &lt;span class=&quot;n&quot;&gt;ros&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop_rate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;publisher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;advertise&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RCLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;local_cmd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For reference the header file for this class declares the required Boost ASIO facilities as follows:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;boost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io_service&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;boost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serial_port&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Uniform initialization is an easy to read and efficient means of opening the serial stream pipeline. This enables the constructor to simply include a slim one liner which initializes the ROS node that publishes to the topic “local_cmd” - that publishes RCLocal Messages which are a custom defined message defined in the common message package within the chacebot stack.&lt;/p&gt;

&lt;p&gt;After node initialization, the Local Controller’s main function proceeds to call the execution method which contains the infinite while loop that performs all the magic - from reading the input serial message, storing it in a local variable message instance and publishing it to the local_cmd topic. Here is the code contained in this loop:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LocalController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ros&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop_rate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ros&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;eventHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Exception handled with serial read&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;publisher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;publish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;loop_rate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This main event loop clearly illustrates the functionality of this app mentioned above and is wrapped around a catch all that enables the program to process an unexpected message without crashing.&lt;/p&gt;

&lt;p&gt;The last special component of this publisher node is the means by which it extracts sensor data from the serial device via the event handler. This is done through a “regular expression” coined REGEX in cpp and is a very powerful, easy to use, and simple utility provided by the C++ standard library by including the regex library. The usage of this facility is shown here:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LocalController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readSerial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;raw_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;boost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;streambuf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;boost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_until&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;istream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;raw_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputPattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;(&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d{1,4}),(&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d{1,4}),(&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d{1,4})&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;smatch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex_search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;raw_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputPattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rawStatus&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stoi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STEERING&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rcConverter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stoi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DRIVE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rcConverter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stoi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STATUS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rawStatus&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1100&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rawStatus&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                         &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SafetyStatus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_enabled&lt;/span&gt;
                         &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SafetyStatus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_disabled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Regex does not read anything&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STATUS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SafetyStatus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_disabled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The beauty of regex is illustrated in the call to “inputPattern”. This call passes an argument containing specific values and special characters which enable the function to read a string passed to it, and extract specific values as strings (easily translated to ints). The local controller program then pulls this information from the regex via “regex_search” and stores the values in the right places via matches[n].&lt;/p&gt;</content><author><name></name></author><summary type="html">The purpose of this post is to outline the key components of a ROS node I wrote about three months ago in order to create my over complicated RC car. But I have already used the work dedicated here to enable other technologies across my Mechanical Engineering discipline. Such as the rapid prototyping of a mechanism that allows a 150 lb sidewalk delivery robot to climb curbs:</summary></entry><entry><title type="html">Moving Across America During Corona Virus Pandemic</title><link href="http://localhost:4000/2020/07/04/Corona.html" rel="alternate" type="text/html" title="Moving Across America During Corona Virus Pandemic" /><published>2020-07-04T00:00:00-04:00</published><updated>2020-07-04T00:00:00-04:00</updated><id>http://localhost:4000/2020/07/04/Corona</id><content type="html" xml:base="http://localhost:4000/2020/07/04/Corona.html">&lt;p&gt;My first non technical post here. It is a brief one.&lt;/p&gt;

&lt;p&gt;After living in Northern California for three years, the corona virus pandemic pushed our over priced confined space living tolerance over the edge and we decided to move back to the more afforable and less hazardous east coast US for a better quality of life.&lt;/p&gt;

&lt;p&gt;I landed a new job at a great UK based consultancy company and am excited to start contributing there. Very gratefull for them.&lt;/p&gt;

&lt;p&gt;My wife Lily and I are about to begin a 3500 mile journey across the US via our 2016 Acura RDX. Wish us luck.&lt;/p&gt;

&lt;p&gt;(Addendum from 07-07-2020) Here is a picture of Utah grabbed during the second day of our journey:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blog/july2020/utah.jpg&quot; alt=&quot;Utah&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">My first non technical post here. It is a brief one.</summary></entry><entry><title type="html">Code Walkthrough, Firmware running the Chacebot Microcontroller</title><link href="http://localhost:4000/2020/06/21/Firmware.html" rel="alternate" type="text/html" title="Code Walkthrough, Firmware running the Chacebot Microcontroller" /><published>2020-06-21T00:00:00-04:00</published><updated>2020-06-21T00:00:00-04:00</updated><id>http://localhost:4000/2020/06/21/Firmware</id><content type="html" xml:base="http://localhost:4000/2020/06/21/Firmware.html">&lt;p&gt;Chacebot uses an STM32F103C8T6 microcontroller to interpret PWM signals from a three channel RC receiver and streams the values over the serial port to control the drivetrain of the robot. This post contains an overview of the hardware setup and explains the firmware I implemented to make this embedded system work efficiently. The code I developed in this project is an extension from a chapter in Warren Gay’s book : &lt;a href=&quot;https://www.amazon.com/Beginning-STM32-Developing-FreeRTOS-libopencm3/dp/1484236238&quot;&gt;Beginning STM32: Developing with FreeRTOS, libopencm3 and GCC&lt;/a&gt;, specifically Chapter 17 titled “PWM Input with Timer 4”.&lt;/p&gt;

&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;

&lt;p&gt;The reason why I purchased Warren’s book was so that I can learn more about embedded systems and implement this RC receiver interpreting functionality in a more elegant way than the lower hanging fruit alternative which was to use an Arduino. Using the arduino for this would have been very easy because the arduino platform has built in functions that allow you pick an analog input pin and will set up the relevant timers and scale the length of the pulse under the hood without having to write all of the code to do so. However this is not how this system would be deployed in industry because the Arduino platform is not scalable and it does not allow for multitasking. Everything in Arduino is synchronous meaning it only does one task at a time, therefore there is the possibility of missing input signals since it cannot monitor all RC input pins at the same time. This is where FreeRTOS comes in. Through Warren’s book I was able to learn how to implement preemptive multitasking which I will just refer to as a “task”. This allows for me to set up modular routines or “jobs” that can be initiated and run at the discretion of the microprocessor scheduler which is very efficient. Running multiple jobs this way does not always mean that they are done in parallel, however it does enable asynchronous behavior.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blog/june2020/chacebot-stm32.jpg&quot; alt=&quot;Chacebot RC Control Setup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Above, the chacebot STM32 setup is shown. This includes the off the shelf RC transmitter and reciever combo ($30 from amazon) which is used for any typical RC hobby application. The RC Receiver (little black box with an antenna) is mounted via VHB foam tape to a breadboard containing the STM32F103 microcontroller. The STM32 is wired to the RC receiver using jumper wires running Vcc (+5v), GND, and connections between channel 1, 2, 3 of the RC receiver to pins PB6, PA6, and PA0 respectively. The pinout diagram for the STM32 board below indicates the physical location of these pins:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blog/june2020/STM32-Pinout.png&quot; alt=&quot;STM32 Pinout&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The code that follows in this post can be found in the &lt;a href=&quot;https://github.com/chacebot/chacebot_firmware&quot;&gt;Chacebot Firmware Github Repo&lt;/a&gt; and can be built and used by following the instructions at &lt;a href=&quot;https://github.com/ve3wwg/stm32f103c8t6&quot;&gt;Warren Gay’s Tutorial Repo for the STM32&lt;/a&gt;. The only project in my repo is the RC controller and it can be found in this directory:&lt;/p&gt;

&lt;p&gt;chacebot_firmware/
       |- README.md
       |- libopencm3
       |- FreeRTOSv10.0.1
       |- libwwg
       |-rtos
           |- chacebot_rc_reciever/        Project Source Code Directory
           |   |- main.c                   Main file where all the magic happens&lt;/p&gt;

&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;p&gt;Starting with a top down approach, we will first look at the main function of the code and then dig into the details of what it contains. Here is what the main function looks like:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 
 &lt;span class=&quot;n&quot;&gt;rcc_clock_setup_in_hse_8mhz_out_72mhz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
 
 &lt;span class=&quot;n&quot;&gt;rcc_periph_clock_enable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RCC_GPIOC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gpio_set_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIOC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_MODE_OUTPUT_2_MHZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_CNF_OUTPUT_PUSHPULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;GPIO13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gpio_clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIOC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// LED off&lt;/span&gt;
 
 &lt;span class=&quot;n&quot;&gt;usb_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;std_set_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mcu_usb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Use USB for std I/O&lt;/span&gt;
 
 &lt;span class=&quot;n&quot;&gt;xTaskCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;steering&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;xTaskCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;drive&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;xTaskCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;status&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;xTaskCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;send&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;vTaskStartScheduler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First we set up the main system clock speed of 72 MHz on the STM32 and then set up the built in LED. Next the usb interface is initialized. This interface is provided by Warren Gay which is very easy to use and allows us to send data from the board to a computer over the serial port. Finally there is the part where my code comes in (with inspiration from Mr. Gay). I start 4 tasks using the FreeRTOS preemptive scheduling facilities by calling the function “xTaskCreate(task code, task name, NULL, task priority, NULL). The two NULL pointers are to use the function without pvParameter and pxCreatedTask functionality which are optional. The first three tasks are pretty much identical and are used to set up and execute the timers to monitor PWM signals on three specific pins using their own timers. The last task is used to package up the pwm values stored in a stack variable and send them over the serial port. Lastly this main function calls “vTaskStartScheduler()” which initiates the tasks to run on the STM32. Each task has their own infinite loop just like the one seen at the end of this main function so that the program continues to interpret PWM data and stream it over the serial port forever. The reason for the redundant infinite loop in the main function allows for the program to never exit. Now lets take a look under the hood of one of the PWM timer tasks:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;task1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__attribute__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unused&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Steering Task&lt;/span&gt;
 
 &lt;span class=&quot;n&quot;&gt;rcc_periph_clock_enable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RCC_TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Need TIM4 clock&lt;/span&gt;
 
 &lt;span class=&quot;c1&quot;&gt;// PB6 == TIM4.CH1&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;rcc_periph_clock_enable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RCC_GPIOB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// Need GPIOB clock&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gpio_set_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIOB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_MODE_INPUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// Input&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;GPIO_CNF_INPUT_FLOAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// PB6=TIM4.CH1&lt;/span&gt;
 
 &lt;span class=&quot;c1&quot;&gt;// TIM4:&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;timer_disable_counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;rcc_periph_reset_pulse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RST_TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;nvic_set_priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NVIC_DMA1_CHANNEL3_IRQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;nvic_enable_irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NVIC_TIM4_IRQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;timer_set_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_CR1_CKD_CK_INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_CR1_CMS_EDGE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_CR1_DIR_UP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;timer_set_prescaler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;72&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
 &lt;span class=&quot;n&quot;&gt;timer_ic_set_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_IC2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_IC_IN_TI1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;timer_ic_set_filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_IC_IN_TI1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_IC_CK_INT_N_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
 &lt;span class=&quot;n&quot;&gt;timer_slave_set_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_SMCR_SMS_RM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;timer_slave_set_trigger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_SMCR_TS_TI1FP1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;TIM_CCER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM_CCER_CC2P&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_CCER_CC2E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;TIM_CCER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_CCER_CC2P&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_CCER_CC2E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;timer_ic_enable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_IC2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;timer_enable_irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_DIER_CC2IE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;timer_enable_counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;vTaskDelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There is a lot to swallow here but it is all mainly initializer stuff to support the timer and to configure how it scales the output to return the results we want. The STM32 has 4 general purpose timers and we are using three of them, one for each channel of the RC receiver. Channel one (steering) is wired to the timer in the example shown above which is timer 4 on pin PB6. Channel two (drive) and channel three (safety switch) are wired to timer 3 on pin PA6 and timer 2 on pin PA0 respectively. The “B” in PB6 stands for peripheral bus “B” which needs to be activated before any of the GPIO functionality on that bus is used. This is done with the call to rcc_periph_clock_enable(RCC_GPIOB) which starts the clock for that bus. You’ll also notice that this same method was called above it but with the argument of “RCC_TIM4” which sets another clock just for the timer. Embedded systems are super specific and if everything is not configured properly then nothing will work. It is also very tedious since there is such granularity to what has to be configured. After the clocks are enabled then the specific pin GPIO6 on the GPIOB bus is initialized as an input pin to be used by the timer.&lt;/p&gt;

&lt;p&gt;After everything is initialized for this channel, the timer is further configured to start counting when the PWM signal rises and counts until it falls again. This length is the “Pulse Width” in Pulse Width Modulation (PWM). The timer counts in units of the system clock intervals and then needs to be converted to usable time (ms) which is done by calling timer_set_prescaler(TIM4, 72 - 1). The rest of the function calls are used to further configure how the timer handles noise with a filter and configures the interrupt service routine functionality that works kind of like a callback function to store the data in a stack variable. Lastly this task, just like all the others, has an infinite loop so that it keeps timing the length of PWM pulses for as long as the STM32 is powered. Next we will look into the interrupt service routine and the variable it stores our valuable RC controller command data in:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STEERING&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DRIVE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENABLE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tim4_isr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_SR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_SR_CC2IF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;STEERING&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_CCR2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;timer_clear_flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TIM4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIM_SR_CC2IF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Starting from the top, three unsigned (positive only) 32 bit integers are declared to zero, one for each of the RC channels. Then the timer 4 interrupt service routine is defined as void because it never returns anything. Instead it is called through the timer tasks, stores the appropriate channel’s PWM signal data into the corresponding variable, and then clears the timer flag so that it can start timing again. This is pretty simple right? For each channel we have a task that runs infinitely that records the amount of time passed since the last voltage spike on the pin until the voltage drops again and then stores that value into a variable which we will then send over the serial port to a computer to be used modularly to provide input to any application. Let’s take a look at the final piece of the puzzle which is the task for sending this data over the serial port:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;task4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__attribute__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unused&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Sending Task&lt;/span&gt;
 
 &lt;span class=&quot;n&quot;&gt;gpio_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIOC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// LED on&lt;/span&gt;
 
 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;vTaskDelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;std_printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;%u,%u,%u&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STEERING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DRIVE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ENABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ENABLE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;gpio_clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIOC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// LED on&lt;/span&gt;
 
   &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ENABLE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;gpio_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIOC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When task4 is kicked off in the main function, the task initializes the board built in LED to shine by setting the pin to high with “gpio_set(GPIOC, GPIO13)”. Then the task enters it’s infinite loop that continuously writes to the serial buffer with the &amp;lt;STEERING,DRIVE,ENABLE&amp;gt; format. This print call includes the special “\r” and “\n” characters to indicate the end of the message and to write to a new line the next cycle. Lastly there is added functionality here that controls the LED indicator depending on the status of the ENABLE status channel value. If ENABLE (button clicked on controller) is above 1500 (ms) it will turn the LED on and if under 1500 will turn it off.&lt;/p&gt;

&lt;p&gt;Thank you for reading and please let me know if you have any suggestions to how I could make improvements!&lt;/p&gt;

&lt;p&gt;-Chace&lt;/p&gt;</content><author><name></name></author><summary type="html">Chacebot uses an STM32F103C8T6 microcontroller to interpret PWM signals from a three channel RC receiver and streams the values over the serial port to control the drivetrain of the robot. This post contains an overview of the hardware setup and explains the firmware I implemented to make this embedded system work efficiently. The code I developed in this project is an extension from a chapter in Warren Gay’s book : Beginning STM32: Developing with FreeRTOS, libopencm3 and GCC, specifically Chapter 17 titled “PWM Input with Timer 4”. Background The reason why I purchased Warren’s book was so that I can learn more about embedded systems and implement this RC receiver interpreting functionality in a more elegant way than the lower hanging fruit alternative which was to use an Arduino. Using the arduino for this would have been very easy because the arduino platform has built in functions that allow you pick an analog input pin and will set up the relevant timers and scale the length of the pulse under the hood without having to write all of the code to do so. However this is not how this system would be deployed in industry because the Arduino platform is not scalable and it does not allow for multitasking. Everything in Arduino is synchronous meaning it only does one task at a time, therefore there is the possibility of missing input signals since it cannot monitor all RC input pins at the same time. This is where FreeRTOS comes in. Through Warren’s book I was able to learn how to implement preemptive multitasking which I will just refer to as a “task”. This allows for me to set up modular routines or “jobs” that can be initiated and run at the discretion of the microprocessor scheduler which is very efficient. Running multiple jobs this way does not always mean that they are done in parallel, however it does enable asynchronous behavior. Above, the chacebot STM32 setup is shown. This includes the off the shelf RC transmitter and reciever combo ($30 from amazon) which is used for any typical RC hobby application. The RC Receiver (little black box with an antenna) is mounted via VHB foam tape to a breadboard containing the STM32F103 microcontroller. The STM32 is wired to the RC receiver using jumper wires running Vcc (+5v), GND, and connections between channel 1, 2, 3 of the RC receiver to pins PB6, PA6, and PA0 respectively. The pinout diagram for the STM32 board below indicates the physical location of these pins: The code that follows in this post can be found in the Chacebot Firmware Github Repo and can be built and used by following the instructions at Warren Gay’s Tutorial Repo for the STM32. The only project in my repo is the RC controller and it can be found in this directory: chacebot_firmware/ |- README.md |- libopencm3 |- FreeRTOSv10.0.1 |- libwwg |-rtos |- chacebot_rc_reciever/ Project Source Code Directory | |- main.c Main file where all the magic happens Code Starting with a top down approach, we will first look at the main function of the code and then dig into the details of what it contains. Here is what the main function looks like: int main(void) { rcc_clock_setup_in_hse_8mhz_out_72mhz(); rcc_periph_clock_enable(RCC_GPIOC); gpio_set_mode(GPIOC, GPIO_MODE_OUTPUT_2_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, GPIO13); gpio_clear(GPIOC, GPIO13); // LED off usb_start(1, 1); std_set_device(mcu_usb); // Use USB for std I/O xTaskCreate(task1, &quot;steering&quot;, 100, NULL, 1, NULL); xTaskCreate(task2, &quot;drive&quot;, 100, NULL, 1, NULL); xTaskCreate(task3, &quot;status&quot;, 100, NULL, 1, NULL); xTaskCreate(task4, &quot;send&quot;, 100, NULL, 1, NULL); vTaskStartScheduler(); for (;;) ; return 0; } First we set up the main system clock speed of 72 MHz on the STM32 and then set up the built in LED. Next the usb interface is initialized. This interface is provided by Warren Gay which is very easy to use and allows us to send data from the board to a computer over the serial port. Finally there is the part where my code comes in (with inspiration from Mr. Gay). I start 4 tasks using the FreeRTOS preemptive scheduling facilities by calling the function “xTaskCreate(task code, task name, NULL, task priority, NULL). The two NULL pointers are to use the function without pvParameter and pxCreatedTask functionality which are optional. The first three tasks are pretty much identical and are used to set up and execute the timers to monitor PWM signals on three specific pins using their own timers. The last task is used to package up the pwm values stored in a stack variable and send them over the serial port. Lastly this main function calls “vTaskStartScheduler()” which initiates the tasks to run on the STM32. Each task has their own infinite loop just like the one seen at the end of this main function so that the program continues to interpret PWM data and stream it over the serial port forever. The reason for the redundant infinite loop in the main function allows for the program to never exit. Now lets take a look under the hood of one of the PWM timer tasks: static void task1(void *args __attribute__((unused))) { //Steering Task rcc_periph_clock_enable(RCC_TIM4); // Need TIM4 clock // PB6 == TIM4.CH1 rcc_periph_clock_enable(RCC_GPIOB); // Need GPIOB clock gpio_set_mode(GPIOB, GPIO_MODE_INPUT, // Input GPIO_CNF_INPUT_FLOAT, GPIO6); // PB6=TIM4.CH1 // TIM4: timer_disable_counter(TIM4); rcc_periph_reset_pulse(RST_TIM4); nvic_set_priority(NVIC_DMA1_CHANNEL3_IRQ, 2); nvic_enable_irq(NVIC_TIM4_IRQ); timer_set_mode(TIM4, TIM_CR1_CKD_CK_INT, TIM_CR1_CMS_EDGE, TIM_CR1_DIR_UP); timer_set_prescaler(TIM4, 72 - 1); timer_ic_set_input(TIM4, TIM_IC2, TIM_IC_IN_TI1); timer_ic_set_filter(TIM4, TIM_IC_IN_TI1, TIM_IC_CK_INT_N_2); timer_slave_set_mode(TIM4, TIM_SMCR_SMS_RM); timer_slave_set_trigger(TIM4, TIM_SMCR_TS_TI1FP1); TIM_CCER(TIM4) &amp;amp;= ~(TIM_CCER_CC2P | TIM_CCER_CC2E); TIM_CCER(TIM4) |= TIM_CCER_CC2P | TIM_CCER_CC2E; timer_ic_enable(TIM4, TIM_IC2); timer_enable_irq(TIM4, TIM_DIER_CC2IE); timer_enable_counter(TIM4); for (;;) { vTaskDelay(20); } } There is a lot to swallow here but it is all mainly initializer stuff to support the timer and to configure how it scales the output to return the results we want. The STM32 has 4 general purpose timers and we are using three of them, one for each channel of the RC receiver. Channel one (steering) is wired to the timer in the example shown above which is timer 4 on pin PB6. Channel two (drive) and channel three (safety switch) are wired to timer 3 on pin PA6 and timer 2 on pin PA0 respectively. The “B” in PB6 stands for peripheral bus “B” which needs to be activated before any of the GPIO functionality on that bus is used. This is done with the call to rcc_periph_clock_enable(RCC_GPIOB) which starts the clock for that bus. You’ll also notice that this same method was called above it but with the argument of “RCC_TIM4” which sets another clock just for the timer. Embedded systems are super specific and if everything is not configured properly then nothing will work. It is also very tedious since there is such granularity to what has to be configured. After the clocks are enabled then the specific pin GPIO6 on the GPIOB bus is initialized as an input pin to be used by the timer. After everything is initialized for this channel, the timer is further configured to start counting when the PWM signal rises and counts until it falls again. This length is the “Pulse Width” in Pulse Width Modulation (PWM). The timer counts in units of the system clock intervals and then needs to be converted to usable time (ms) which is done by calling timer_set_prescaler(TIM4, 72 - 1). The rest of the function calls are used to further configure how the timer handles noise with a filter and configures the interrupt service routine functionality that works kind of like a callback function to store the data in a stack variable. Lastly this task, just like all the others, has an infinite loop so that it keeps timing the length of PWM pulses for as long as the STM32 is powered. Next we will look into the interrupt service routine and the variable it stores our valuable RC controller command data in: static volatile uint32_t STEERING = 0, DRIVE = 0, ENABLE = 0; void tim4_isr(void) { uint32_t sr = TIM_SR(TIM4); if (sr &amp;amp; TIM_SR_CC2IF) { STEERING = TIM_CCR2(TIM4); timer_clear_flag(TIM4, TIM_SR_CC2IF); } } Starting from the top, three unsigned (positive only) 32 bit integers are declared to zero, one for each of the RC channels. Then the timer 4 interrupt service routine is defined as void because it never returns anything. Instead it is called through the timer tasks, stores the appropriate channel’s PWM signal data into the corresponding variable, and then clears the timer flag so that it can start timing again. This is pretty simple right? For each channel we have a task that runs infinitely that records the amount of time passed since the last voltage spike on the pin until the voltage drops again and then stores that value into a variable which we will then send over the serial port to a computer to be used modularly to provide input to any application. Let’s take a look at the final piece of the puzzle which is the task for sending this data over the serial port: static void task4(void *args __attribute__((unused))) { //Sending Task gpio_set(GPIOC, GPIO13); // LED on for (;;) { vTaskDelay(20); std_printf(&quot;&amp;lt;%u,%u,%u&amp;gt;\r\n&quot;, (unsigned)STEERING, (unsigned)DRIVE, (unsigned)ENABLE); if (ENABLE &amp;gt; 1500) gpio_clear(GPIOC, GPIO13); // LED on else if (ENABLE &amp;lt; 1500) gpio_set(GPIOC, GPIO13); } } When task4 is kicked off in the main function, the task initializes the board built in LED to shine by setting the pin to high with “gpio_set(GPIOC, GPIO13)”. Then the task enters it’s infinite loop that continuously writes to the serial buffer with the &amp;lt;STEERING,DRIVE,ENABLE&amp;gt; format. This print call includes the special “\r” and “\n” characters to indicate the end of the message and to write to a new line the next cycle. Lastly there is added functionality here that controls the LED indicator depending on the status of the ENABLE status channel value. If ENABLE (button clicked on controller) is above 1500 (ms) it will turn the LED on and if under 1500 will turn it off. Thank you for reading and please let me know if you have any suggestions to how I could make improvements! -Chace</summary></entry><entry><title type="html">My RC Controlled Robot - Chacebot, Powered by ROS and C++</title><link href="http://localhost:4000/2020/05/11/Chacebot.html" rel="alternate" type="text/html" title="My RC Controlled Robot - Chacebot, Powered by ROS and C++" /><published>2020-05-11T00:00:00-04:00</published><updated>2020-05-11T00:00:00-04:00</updated><id>http://localhost:4000/2020/05/11/Chacebot</id><content type="html" xml:base="http://localhost:4000/2020/05/11/Chacebot.html">&lt;p&gt;Chacebot has been my side project over the past month and it has been a very fun platform for me to demonstrate my C++ skills and get more hands on experience with the Robotic Operating System (ROS).&lt;/p&gt;

&lt;h3 id=&quot;why-did-i-choose-this-project&quot;&gt;Why did I choose this project?&lt;/h3&gt;

&lt;p&gt;Throughout the past three years of my actuation design career, I have always met a large blocker once all my prototypes were assembled - lack of a control pipeline. My motivation behind this project is to produce a plugin that can easily integrate into a software stack containing motor drivers and directly start controlling motion in open loop. This plugin is a very valuable tool to add to my R and D toolbox so that I can learn from my designs faster and iterate even quicker to produce quality - well tested designs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blog/may2020/chacebot_lightweight.gif&quot; alt=&quot;GoPiGo3 gif&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;requirements-for-this-project&quot;&gt;Requirements for this project:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Must be cheap and simple hardware. Developing hardware is my day job, I wanted this project to fully focus on sharpening my software / firmware knowledge&lt;/li&gt;
  &lt;li&gt;Must be implemented with ROS I know a lot of companies hate on ROS, however most of the custom middleware alternatives are not much different in terms of message publishing and subscription. Using a common middleware enables this plugin to be more adaptable to a range of projects.&lt;/li&gt;
  &lt;li&gt;Must be written in C++. In addition to ROS, a lot of companies also dislike python for robotics and that is something I can get on board with when it comes to writing low level code. Although python is a simpler language to learn and adapt to a wide variety of problems due to the abundance of open source libraries, it is not efficient and safe. Therefore I feel it C++ is a great choice because of its robustness and efficiency.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Although this code is currently running on my raspberry pi powered robot, my future plans are to extend it to any type of robot using an operating system / CPU that can support ROS. With that said, here is an overview of my current setup.&lt;/p&gt;

&lt;p&gt;The robot base, drivetrain, and motor drivers are sourced off the shelf from a company called Dexter industries. They make very affordable and fun robotics parts for education. This package without the raspberry pi included cost around $120 and the quality is not terrible. The robot is a holonomic differential drive robot base powered with two brushed DC motors with on axis encoders (on the motor axis). These motors have right angled gear heads with a reduction so the motor driver has to do a little math to get the velocity settings correct. Lastly this robot includes an arduino atmega microcontroller mounted on a custom PCBA running a 12V rail to power the motors. This microcontroller enables a raspberry pi 4 to easily communicate to the peripherals and drive wheels using SPI. Since this microcontroller comes flashed with it’s own firmware off the shelf, I will not discuss it because I did not code it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blog/may2020/gpg_iso_right.jpg&quot; alt=&quot;GPG ISO Still&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I splurged and purchased the dexter industries imu and ultrasonic sensor in addition to the raspberry pi camera as shown in the image above.&lt;/p&gt;

&lt;p&gt;Also, what else is that on top? Well, that is the chacebot RC receiver wired up to a STM32F108 microcontroller that talks to the raspberry pi via usb. The RC receiver is paired with a specific 3 channel RC transmitter that is a very common item used to drive RC cars.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blog/may2020/rc_transmitter.jpg&quot; alt=&quot;GPG ISO Still&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I am currently using this device to provide ergonomic open loop control of the drivetrain of my robot (and can be easily modified for any mobile robot). Although this is a major part of this project, it is not the focus of the blog post and will leave you, the reader, something to look forward to in a future post! Let’s now take a look at the ROS software stack running on chacebot.&lt;/p&gt;

&lt;h3 id=&quot;package-overview&quot;&gt;Package Overview&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blog/may2020/cfd.png&quot; alt=&quot;GPG Control Flow Chart&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Currently the ROS stack is composed of Three main components.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Local Controller:  ROS node that continuously reads the serial buffer on a port specified in the source code and publishers it to a topic called /local_cmd&lt;/li&gt;
  &lt;li&gt;Motion Allocator: The middleman that subscribes to the /local_cmd topic, processes that steering and drive input and maps that to the appropriate /left_wheel_speed and /right_wheel_speed topics it publishes&lt;/li&gt;
  &lt;li&gt;GoPiGo3 Driver: A low level node written in python that subscribes to multiple topics and is composed of the libraries provided by dexter industries with their robot. I did not write this code because the libraries are in python and the purpose of this project was to further develop my C++ skills in addition to not writing hardware specific code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is the overview of the file structure of my ROS stack: It is composed of 4 packages, one for each of the nodes listed above and another for which is solely for custom messages that does not contain any scripts or source code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chacebot_ws/
    |- README.md
    |- src/                     Source Code
        |- gopigo3_node/        GoPiGo3 Python ROS Driver
        |   |- launch           Launch Files
        |   |- msg              Custom Driver Messages use by the driver only
        |   |- src              Source code aka python scripts in this context
        |   |- srv              Custom services within the driver package
        |   |- CMakeLists.txt
        |   |- package.xml
        |- local_controller/    C++ Pacakge for interpeting RC reciever
        |   |- src
        |   |- CMakeLists.txt
        |   |- package.xml
        |- motion_allocator/    C++ Package to make steering, drive to L,R wheel velocities
        |   |- src
        |   |- CMakeLists.txt
        |   |- package.xml
        |-  msg/                Package for custom messages used across multiple nodes
        |   |- msg
        |   |   |-RCLocal.msg   Custom Message for sending RC transmitter values
        |   |- CMakeLists.txt
        |   |- package.xml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Each package contains a CMakeLists.txt and a package.xml that are required by ROS to configure the package correctly for it to successfully be built. These files specify where to find includes, what executables to add, flags for message generation, etc.. We will dive into these specifics in future blog posts about each package.&lt;/p&gt;

&lt;p&gt;Lastly, before we dive into the source code for this project in future posts, I would like to share the required dependencies so that anyone interested can try and build this project on their raspberry pi powered dexter robot. Here is a list in order of installation.&lt;/p&gt;

&lt;h3 id=&quot;how-to-install&quot;&gt;How to Install&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;A raspbian image with ROS kinetic preinstalled. I found a great one provided by a gentleman named Jack Pien from Hadabot, you can find the image through this &lt;a href=&quot;https://github.com/ROSbots/rosbots_setup_tools&quot;&gt;Github Repo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;The dexter industries driver libraries to communicate with the microcontroller provided with the GoPiGo. This main drivers are found &lt;a href=&quot;https://github.com/DexterInd/GoPiGo3&quot;&gt;here&lt;/a&gt; and if you are interested in using their sensor accessories, the added libraries to drive those components are found &lt;a href=&quot;https://github.com/DexterInd/DI_Sensors&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;If using the raspbian image with ROS I mentioned above, you will also need to install ROS nav-msgs because they are required by the ROS GoPiGo3 driver used in this project. These nav-messages provide what is needed for odometry. This is a complex thing to do, luckily someone else ran into this issue when trying to use this driver on this specific ROS image and the instructions for successfully installing these message dependencies are found &lt;a href=&quot;https://github.com/ros-gopigo/gopigo3_node/issues/6&quot;&gt;here&lt;/a&gt;. Tldr, seems like the ros install on the raspbian image was non traditional and uses the ROS root directories (the standard /opt/ros location) and instead is installed in a subfolder of the home directory.&lt;/li&gt;
  &lt;li&gt;Once the above is completed you are ready to clone this project’s workspace into your file system using
    &lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;git clone https://github.com/chacebot/chacebot_ws
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now that you have this project installed, please try running the individual packages to  get more practice with ros! The usage and details for each package will follow in future blog posts for each package. Thank you for reading this far, cheers!&lt;/p&gt;</content><author><name></name></author><summary type="html">Chacebot has been my side project over the past month and it has been a very fun platform for me to demonstrate my C++ skills and get more hands on experience with the Robotic Operating System (ROS).</summary></entry><entry><title type="html">First Post! Udacity C++ Nanodegree</title><link href="http://localhost:4000/2020/04/01/Udacity.html" rel="alternate" type="text/html" title="First Post! Udacity C++ Nanodegree" /><published>2020-04-01T00:00:00-04:00</published><updated>2020-04-01T00:00:00-04:00</updated><id>http://localhost:4000/2020/04/01/Udacity</id><content type="html" xml:base="http://localhost:4000/2020/04/01/Udacity.html">&lt;p&gt;I graduated from the Udacity C++ Nanodegree program this week and I feel very good about what I accomplished over the past four months. Prior to this class my programming experience was mainly python and at the intermediate level. I had a firm grasp on computer science fundamentals and understood the main principles behind object oriented programming. However I still did not know much about the difference between dynamically scripted languages such as python and compiled languages like C++. I also did not know much about algorithms and how they are structured to produce useful output stemming from basic data input.&lt;/p&gt;

&lt;p&gt;This program required me to really put my existing programming knowledge (python) to work and extend it to the vast capabilities that C++ has to offer. The program was divided into 4 primary courses that seemed to fall into two categories of fundamentals and advanced topics.&lt;/p&gt;

&lt;p&gt;The fundamentals covered in the first two sections include general C++ syntax, procedural programming components such as methods, objects, and data structures, and finally an extensive coverage of object oriented programming. I learned a lot about what C++ had to offer during these sections in addition to learning about the A* search algorithm which is super cool. This was my biggest takeaway from the first half of this course because it was my first encounter with an extensive depth first search algorithm. My only previous experience with something similar to this is the application of sorting lists and evaluating the different associated compute costs for different methods of sorting. Udacity taught this information in a very linear constructive way that allowed me to put the building blocks together at my own pace and enabled me to really understand the content. The result of this work, yielding the shortest traversable path from point A to B within open street maps is shown below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blog/april2020/route_planner.png&quot; alt=&quot;OSM A* Search Route Planning Project&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The second part of the course was my favorite because of how much it challenged me to learn about advanced programming concepts such memory management and concurrency. The Udacity instructor did a great job covering how C++ evolved memory management over the past several decades into what is now known as “Modern C++ (C++ 17)”. They covered the importance of memory allocation and deallocation on the heap in addition to “the rule of 5” and how these rules ensure appropriate handling of resources. Lastly they wrapped up the memory management section with a lesson on smart pointers and all the associated built in features they include which allow the programmer to focus more on what they want the code to do and lessen the burden of memory leaks and other memory related bugs. The knowledge I gained from this section was put to the test in the Memory Management Chatbot project where I had to take an existing, working application and modify it to become more efficient through the use of responsible resource allocation on the heap. Mainly focusing on transforming raw pointers into smart pointers and utilizing move semantics where ownership needed to be transfered.&lt;/p&gt;

&lt;p&gt;All concepts so far throughout this course converged in the final lesson on concurrency which was by far my favorite because of all the “moving pieces”, literally. The biggest motivation for my interest in programming is due to the dynamics of it and concurrency makes this work multidimensional, which fascinates me.  We started this lesson learning about the creation and handling of single threads and then expanded this into multithreaded applications while comparing the increase in cpu utilization for each example. Next was a transition to learning about tasks, promises, and futures and how these extend the concept of threads very much like how smart pointers extend the handling of regular raw pointers. I feel that the content in this section was my best takeaway from the whole course and will be sure to exercise it throughout my future endeavors. Multithreaded applications are extremely powerful and dangerous at the same time which makes them so much fun to work with.&lt;/p&gt;

&lt;p&gt;The lesson on concurrency concluded with a project that involved the simultaneous simulation of multiple vehicle objects each with their own thread. Udacity made this project extremely fun because they integrated a great visual front end that really helps visualize the state of each thread (shown below). All of my efforts were involved in the creation and management of all threads and making that functionality accessible in the main loop.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blog/april2020/traffic_simulator.png&quot; alt=&quot;Concurrent Traffic Simulator&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In conclusion my biggest takeaway from this course was learning and practice of the C++ advanced concepts - memory management and concurrency. I enjoyed the concurrency portion so much that I decided to make it the focal point of my final project which extended the snake game to make it multithreaded through the addition of a dynamic obstacle running in it’s own thread. I am extremely excited to apply what I learned in this course to my personal projects and create very intelligent robots. My biggest motivation currently is to create my own object detection in avoidance pipeline for my personal robot (it will definitely include threads!).&lt;/p&gt;

&lt;!--! [Snake Game Extension, Capstone](/assets/images/blog/april2020/snake_game.png) --&gt;

&lt;p&gt;Below is a summary of all the projects I worked on throughout the Nanodegree course along with a link to the source code in my GitHub repo. Enjoy!&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/chacebot/cpp_udacity/tree/master/CppND-Route-Planning-Project_cm&quot;&gt;OSM Route Planner Project&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/chacebot/cpp_udacity/tree/master/CppND-System-Monitor-Project-Updated_cm&quot;&gt;Real Time System Monitor Project&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/chacebot/cpp_udacity/tree/master/CppND-Memory-Management-Chatbot_cm&quot;&gt;Memory Management Chatbot&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/chacebot/cpp_udacity/tree/master/CppND-Concurrent-Traffic-Simulation&quot;&gt;Concurrent Traffic Simulator&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/chacebot/cpp_udacity/tree/master/CppND-Capstone-Snake-Game_cm&quot;&gt;Capstone - Sname Game Extension&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">I graduated from the Udacity C++ Nanodegree program this week and I feel very good about what I accomplished over the past four months. Prior to this class my programming experience was mainly python and at the intermediate level. I had a firm grasp on computer science fundamentals and understood the main principles behind object oriented programming. However I still did not know much about the difference between dynamically scripted languages such as python and compiled languages like C++. I also did not know much about algorithms and how they are structured to produce useful output stemming from basic data input.</summary></entry></feed>